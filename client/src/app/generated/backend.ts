//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    hangfire_FireAndForgetJob(): Promise<string> {
        let url_ = this.baseUrl + "/private-api/Hangfire/IFireAndForgetJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHangfire_FireAndForgetJob(_response);
        });
    }

    protected processHangfire_FireAndForgetJob(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    hangfire_DelayedJob(): Promise<string> {
        let url_ = this.baseUrl + "/private-api/Hangfire/IDelayedJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHangfire_DelayedJob(_response);
        });
    }

    protected processHangfire_DelayedJob(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    hangfire_ContinuousJob(): Promise<string> {
        let url_ = this.baseUrl + "/private-api/Hangfire/IContinuousJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHangfire_ContinuousJob(_response);
        });
    }

    protected processHangfire_ContinuousJob(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    hangfire_RecurringJobs(): Promise<string> {
        let url_ = this.baseUrl + "/private-api/Hangfire/IRecurringJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHangfire_RecurringJobs(_response);
        });
    }

    protected processHangfire_RecurringJobs(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    exchangeRate_Post(): Promise<Currency[]> {
        let url_ = this.baseUrl + "/private-api/ExchangeRate/get-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExchangeRate_Post(_response);
        });
    }

    protected processExchangeRate_Post(response: Response): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Currency[]>(null as any);
    }

    exchangeRate_GetListExchange(): Promise<Currency[]> {
        let url_ = this.baseUrl + "/private-api/ExchangeRate/get-list-realtime";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExchangeRate_GetListExchange(_response);
        });
    }

    protected processExchangeRate_GetListExchange(response: Response): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Currency[]>(null as any);
    }

    currency_GetPagingList(input: PagedFullInputDto): Promise<PagedResultDtoOfCurrencyDto> {
        let url_ = this.baseUrl + "/private-api/Currency/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency_GetPagingList(_response);
        });
    }

    protected processCurrency_GetPagingList(response: Response): Promise<PagedResultDtoOfCurrencyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCurrencyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultDtoOfCurrencyDto>(null as any);
    }

    currency_GetById(id: number): Promise<CommonResultDtoOfCurrencyDto> {
        let url_ = this.baseUrl + "/private-api/Currency/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency_GetById(_response);
        });
    }

    protected processCurrency_GetById(response: Response): Promise<CommonResultDtoOfCurrencyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonResultDtoOfCurrencyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonResultDtoOfCurrencyDto>(null as any);
    }

    currency_Create(input: CurrencyDto): Promise<CommonResultDtoOfCurrencyDto> {
        let url_ = this.baseUrl + "/private-api/Currency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency_Create(_response);
        });
    }

    protected processCurrency_Create(response: Response): Promise<CommonResultDtoOfCurrencyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonResultDtoOfCurrencyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonResultDtoOfCurrencyDto>(null as any);
    }

    currency_Update(input: CurrencyDto): Promise<CommonResultDtoOfCurrencyDto> {
        let url_ = this.baseUrl + "/private-api/Currency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency_Update(_response);
        });
    }

    protected processCurrency_Update(response: Response): Promise<CommonResultDtoOfCurrencyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonResultDtoOfCurrencyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonResultDtoOfCurrencyDto>(null as any);
    }

    currency_DeleteById(id: number): Promise<CommonResultDtoOfCurrencyDto> {
        let url_ = this.baseUrl + "/private-api/Currency/DeleteById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency_DeleteById(_response);
        });
    }

    protected processCurrency_DeleteById(response: Response): Promise<CommonResultDtoOfCurrencyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonResultDtoOfCurrencyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonResultDtoOfCurrencyDto>(null as any);
    }
}

export abstract class CreationAuditedEntityOfInteger implements ICreationAuditedEntityOfInteger {
    creationTime?: Date;
    creatorUserId?: number | undefined;

    constructor(data?: ICreationAuditedEntityOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
        }
    }

    static fromJS(data: any): CreationAuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CreationAuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        return data;
    }
}

export interface ICreationAuditedEntityOfInteger {
    creationTime?: Date;
    creatorUserId?: number | undefined;
}

export abstract class AuditedEntityOfInteger extends CreationAuditedEntityOfInteger implements IAuditedEntityOfInteger {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;

    constructor(data?: IAuditedEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
        }
    }

    static fromJS(data: any): AuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditedEntityOfInteger extends ICreationAuditedEntityOfInteger {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
}

export abstract class FullAuditedEntityOfInteger extends AuditedEntityOfInteger implements IFullAuditedEntityOfInteger {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;

    constructor(data?: IFullAuditedEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FullAuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FullAuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFullAuditedEntityOfInteger extends IAuditedEntityOfInteger {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
}

export class Currency extends FullAuditedEntityOfInteger implements ICurrency {
    id?: number;
    currencyName?: string | undefined;
    currencyCode?: string | undefined;
    exchangeRate?: number;
    products?: Product[] | undefined;

    constructor(data?: ICurrency) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.currencyName = _data["currencyName"];
            this.currencyCode = _data["currencyCode"];
            this.exchangeRate = _data["exchangeRate"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyName"] = this.currencyName;
        data["currencyCode"] = this.currencyCode;
        data["exchangeRate"] = this.exchangeRate;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICurrency extends IFullAuditedEntityOfInteger {
    id?: number;
    currencyName?: string | undefined;
    currencyCode?: string | undefined;
    exchangeRate?: number;
    products?: Product[] | undefined;
}

export class Product extends FullAuditedEntityOfInteger implements IProduct {
    id?: number;
    productTitle?: string | undefined;
    url?: string | undefined;
    productImageSrc?: string | undefined;
    availability?: string | undefined;
    price?: string | undefined;
    lastPrice?: number | undefined;
    status?: boolean | undefined;
    sourcePageId?: number;
    sourcePage?: SourcePage | undefined;
    currencyId?: number;
    currency?: Currency | undefined;
    clientCardId?: string;
    clientCard?: ClientCard | undefined;

    constructor(data?: IProduct) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.productTitle = _data["productTitle"];
            this.url = _data["url"];
            this.productImageSrc = _data["productImageSrc"];
            this.availability = _data["availability"];
            this.price = _data["price"];
            this.lastPrice = _data["lastPrice"];
            this.status = _data["status"];
            this.sourcePageId = _data["sourcePageId"];
            this.sourcePage = _data["sourcePage"] ? SourcePage.fromJS(_data["sourcePage"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.clientCardId = _data["clientCardId"];
            this.clientCard = _data["clientCard"] ? ClientCard.fromJS(_data["clientCard"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productTitle"] = this.productTitle;
        data["url"] = this.url;
        data["productImageSrc"] = this.productImageSrc;
        data["availability"] = this.availability;
        data["price"] = this.price;
        data["lastPrice"] = this.lastPrice;
        data["status"] = this.status;
        data["sourcePageId"] = this.sourcePageId;
        data["sourcePage"] = this.sourcePage ? this.sourcePage.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["clientCardId"] = this.clientCardId;
        data["clientCard"] = this.clientCard ? this.clientCard.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProduct extends IFullAuditedEntityOfInteger {
    id?: number;
    productTitle?: string | undefined;
    url?: string | undefined;
    productImageSrc?: string | undefined;
    availability?: string | undefined;
    price?: string | undefined;
    lastPrice?: number | undefined;
    status?: boolean | undefined;
    sourcePageId?: number;
    sourcePage?: SourcePage | undefined;
    currencyId?: number;
    currency?: Currency | undefined;
    clientCardId?: string;
    clientCard?: ClientCard | undefined;
}

export class SourcePage extends FullAuditedEntityOfInteger implements ISourcePage {
    id?: number;
    pageName?: string | undefined;
    domain?: string | undefined;
    products?: Product[] | undefined;

    constructor(data?: ISourcePage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.pageName = _data["pageName"];
            this.domain = _data["domain"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SourcePage {
        data = typeof data === 'object' ? data : {};
        let result = new SourcePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageName"] = this.pageName;
        data["domain"] = this.domain;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISourcePage extends IFullAuditedEntityOfInteger {
    id?: number;
    pageName?: string | undefined;
    domain?: string | undefined;
    products?: Product[] | undefined;
}

export abstract class CreationAuditedEntityOfGuid implements ICreationAuditedEntityOfGuid {
    creationTime?: Date;
    creatorUserId?: number | undefined;

    constructor(data?: ICreationAuditedEntityOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
        }
    }

    static fromJS(data: any): CreationAuditedEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CreationAuditedEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        return data;
    }
}

export interface ICreationAuditedEntityOfGuid {
    creationTime?: Date;
    creatorUserId?: number | undefined;
}

export abstract class AuditedEntityOfGuid extends CreationAuditedEntityOfGuid implements IAuditedEntityOfGuid {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;

    constructor(data?: IAuditedEntityOfGuid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
        }
    }

    static fromJS(data: any): AuditedEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditedEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditedEntityOfGuid extends ICreationAuditedEntityOfGuid {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
}

export abstract class FullAuditedEntityOfGuid extends AuditedEntityOfGuid implements IFullAuditedEntityOfGuid {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;

    constructor(data?: IFullAuditedEntityOfGuid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FullAuditedEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FullAuditedEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFullAuditedEntityOfGuid extends IAuditedEntityOfGuid {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
}

export class ClientCard extends FullAuditedEntityOfGuid implements IClientCard {
    id?: string;
    status?: string | undefined;
    products?: Product[] | undefined;

    constructor(data?: IClientCard) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientCard {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IClientCard extends IFullAuditedEntityOfGuid {
    id?: string;
    status?: string | undefined;
    products?: Product[] | undefined;
}

export class PagedResultDtoOfCurrencyDto implements IPagedResultDtoOfCurrencyDto {
    items?: CurrencyDto[];
    totalCount?: number;

    constructor(data?: IPagedResultDtoOfCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CurrencyDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDtoOfCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDtoOfCurrencyDto {
    items?: CurrencyDto[];
    totalCount?: number;
}

export class CurrencyDto implements ICurrencyDto {
    id?: number;
    currencyName?: string;
    currencyCode?: string;
    exchangeRate?: number;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyName = _data["currencyName"];
            this.currencyCode = _data["currencyCode"];
            this.exchangeRate = _data["exchangeRate"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyName"] = this.currencyName;
        data["currencyCode"] = this.currencyCode;
        data["exchangeRate"] = this.exchangeRate;
        return data;
    }
}

export interface ICurrencyDto {
    id?: number;
    currencyName?: string;
    currencyCode?: string;
    exchangeRate?: number;
}

export class PagedInputDto implements IPagedInputDto {
    maxResultCount?: number;
    skipCount?: number;

    constructor(data?: IPagedInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): PagedInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IPagedInputDto {
    maxResultCount?: number;
    skipCount?: number;
}

export class PagedAndSortedInputDto extends PagedInputDto implements IPagedAndSortedInputDto {
    sorting?: string;

    constructor(data?: IPagedAndSortedInputDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sorting = _data["sorting"];
        }
    }

    static fromJS(data: any): PagedAndSortedInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedAndSortedInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sorting"] = this.sorting;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedAndSortedInputDto extends IPagedInputDto {
    sorting?: string;
}

export class PagedFullInputDto extends PagedAndSortedInputDto implements IPagedFullInputDto {
    arrFilter?: FilterColumns[];
    isFullRecord?: boolean | undefined;
    filter?: string;
    filterFullText?: string;
    mySqlFullTextSearch?: string;
    tenantId?: number | undefined;

    constructor(data?: IPagedFullInputDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["arrFilter"])) {
                this.arrFilter = [] as any;
                for (let item of _data["arrFilter"])
                    this.arrFilter!.push(FilterColumns.fromJS(item));
            }
            this.isFullRecord = _data["isFullRecord"];
            this.filter = _data["filter"];
            this.filterFullText = _data["filterFullText"];
            this.mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): PagedFullInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedFullInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.arrFilter)) {
            data["arrFilter"] = [];
            for (let item of this.arrFilter)
                data["arrFilter"].push(item.toJSON());
        }
        data["isFullRecord"] = this.isFullRecord;
        data["filter"] = this.filter;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["tenantId"] = this.tenantId;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedFullInputDto extends IPagedAndSortedInputDto {
    arrFilter?: FilterColumns[];
    isFullRecord?: boolean | undefined;
    filter?: string;
    filterFullText?: string;
    mySqlFullTextSearch?: string;
    tenantId?: number | undefined;
}

export class FilterColumns implements IFilterColumns {
    fieldName?: string;
    fieldDisplay?: string;
    filterType?: FilterType | undefined;
    values?: string[];

    constructor(data?: IFilterColumns) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.fieldDisplay = _data["fieldDisplay"];
            this.filterType = _data["filterType"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): FilterColumns {
        data = typeof data === 'object' ? data : {};
        let result = new FilterColumns();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["fieldDisplay"] = this.fieldDisplay;
        data["filterType"] = this.filterType;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IFilterColumns {
    fieldName?: string;
    fieldDisplay?: string;
    filterType?: FilterType | undefined;
    values?: string[];
}

export enum FilterType {
    SearchByKeyword = 0,
    Filter = 1,
    Group = 2,
}

export class CommonResultDto implements ICommonResultDto {
    isSuccessful?: boolean;
    statusCode?: HttpStatusCode;
    errorMessage?: string | undefined;
    messageCode?: MessageCode;

    constructor(data?: ICommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.errorMessage = _data["errorMessage"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): CommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["errorMessage"] = this.errorMessage;
        data["messageCode"] = this.messageCode;
        return data;
    }
}

export interface ICommonResultDto {
    isSuccessful?: boolean;
    statusCode?: HttpStatusCode;
    errorMessage?: string | undefined;
    messageCode?: MessageCode;
}

export class CommonResultDtoOfCurrencyDto extends CommonResultDto implements ICommonResultDtoOfCurrencyDto {
    dataResult?: CurrencyDto | undefined;

    constructor(data?: ICommonResultDtoOfCurrencyDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataResult = _data["dataResult"] ? CurrencyDto.fromJS(_data["dataResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommonResultDtoOfCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonResultDtoOfCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICommonResultDtoOfCurrencyDto extends ICommonResultDto {
    dataResult?: CurrencyDto | undefined;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export enum MessageCode {
    IsValid = 100,
    Success = 200,
    NoContent = 204,
    NotValid = 400,
    NotFound = 404,
    Exeption = 500,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}